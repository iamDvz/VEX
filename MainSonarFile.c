#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  sonarRight,     sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  button,         sensorTouch)
#pragma config(Sensor, dgtl4,  sonarLeft,      sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  rightIME,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIME,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_1)
//*               !!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//*~~~~~~~ !! CODE PART !! ~~~~~~~*// //*~~~~~~~ !! CODE PART !! ~~~~~~~*// //*~~~~~~~ !! CODE PART !! ~~~~~~~*//
//*~~~~~~~ !! CODE PART !! ~~~~~~~*// //*~~~~~~~ !! CODE PART !! ~~~~~~~*// //*~~~~~~~ !! CODE PART !! ~~~~~~~*//
//*~~~~~~~ !! CODE PART !! ~~~~~~~*// //*~~~~~~~ !! CODE PART !! ~~~~~~~*// //*~~~~~~~ !! CODE PART !! ~~~~~~~*//
//*~~~~~~~ !! CODE PART !! ~~~~~~~*// //*~~~~~~~ !! CODE PART !! ~~~~~~~*// //*~~~~~~~ !! CODE PART !! ~~~~~~~*//

//*~~~~~~~ !! CONSTANTS !! ~~~~~~~*//
int SPEED = 30;
int DIST = 15;
int ROTATE_DURATION_MSEC = 1500;
int BACK_DURATION_MSEC = 1000;
int BT_COUNT = 3;

//*~~~~~~~ !! VARIABLES !! ~~~~~~~*//
int btCount;

//*~~~~~~~ !! FUNCTIONS !! ~~~~~~~*//
void setMotorsSpeed(int rSp, int lSp){
	motor[rightMotor] = rSp;
	motor[leftMotor] = lSp;
}

int sonars(int mSpeed, int dist, int rotateDur=1500, int backDur=1000) {
	int mSpeedRot = mSpeed*1.2;

	// if button -- nazad pri >= 3 stolknovenii
	if (SensorValue[button]) {
		if (btCount >= BT_COUNT) {
			btCount = 0;
			setMotorsSpeed(-mSpeedRot, -mSpeedRot*1.5);
		}
		btCount += 1;
		setMotorsSpeed(-mSpeed, -mSpeed);
		return backDur;
	}
	// left < dist -- povorot
	if (SensorValue[sonarLeft] < dist) {
		setMotorsSpeed(-mSpeedRot, mSpeedRot);
		return rotateDur;
	}
	// right < dist -- povorot
	if (SensorValue[sonarRight] < dist) {
		setMotorsSpeed(mSpeedRot, -mSpeedRot);
		return rotateDur;
	}
	setMotorsSpeed(mSpeed, mSpeed);
	return 0;
}

//*~~~~~~~ !! MAIN PART !! ~~~~~~~*// //*~~~~~~~ !! MAIN PART !! ~~~~~~~*// //*~~~~~~~ !! MAIN PART !! ~~~~~~~*//
//*~~~~~~~ !! MAIN PART !! ~~~~~~~*// //*~~~~~~~ !! MAIN PART !! ~~~~~~~*// //*~~~~~~~ !! MAIN PART !! ~~~~~~~*//
//*~~~~~~~ !! MAIN PART !! ~~~~~~~*// //*~~~~~~~ !! MAIN PART !! ~~~~~~~*// //*~~~~~~~ !! MAIN PART !! ~~~~~~~*//
//*~~~~~~~ !! MAIN PART !! ~~~~~~~*// //*~~~~~~~ !! MAIN PART !! ~~~~~~~*// //*~~~~~~~ !! MAIN PART !! ~~~~~~~*//

//*~~~~~~~ !! TASKS !! ~~~~~~~*//
task sonarTask() {
	while (true) {
		wait1Msec(sonars(SPEED, DIST, ROTATE_DURATION_MSEC, BACK_DURATION_MSEC));
	}
}

//*~~~~~~~ !! MAIN !! ~~~~~~~*//
task main () {
	startTask(sonarTask);
}
